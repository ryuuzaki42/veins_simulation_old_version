//
// Copyright (C) 2006-2011 Christoph Sommer <christoph.sommer@uibk.ac.at>
//
// Documentation for these modules is at http://veins.car2x.org/
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

#include "veins/modules/application/epidemic/epidemic.h"

using Veins::TraCIMobilityAccess;
using Veins::AnnotationManagerAccess;
using namespace std;

Define_Module(epidemic);

void epidemic::initialize(int stage) {
    BaseWaveApplLayer::initialize_epidemic(stage);
    if (stage == 0) {
        mobility = TraCIMobilityAccess().get(getParentModule());
        traci = mobility->getCommandInterface();
        traciVehicle = mobility->getVehicleCommandInterface();

        cout << source <<  " myMac: " << myMac << " MACToInteger: " << MACToInteger() << " entered in the scenario" << endl;

        WATCH(source);
        WATCH(target);
        WATCH(beaconMessageHopLimit);
        WATCH(maximumEpidemicBufferSize);
        WATCH(sendSummaryVectorInterval);

        if (myId == 0) {
            epidemic::messageId = 1;
        }

        generateMessage();
    }
}

void epidemic::onBeacon(WaveShortMessage* wsm) {
    receivedOnBeacon(wsm);
}

void epidemic::onData(WaveShortMessage* wsm) {
    receivedOnData(wsm);
}

void epidemic::generateTarget() { //Generate a target in order to send a message
    target = "rsu[0]";
}

void epidemic::generateMessage() { //Generate a message in order to be sent to a target
    generateTarget();

    cout << source << " generating one message Id: " << epidemic::messageId << " (" << source << " -> " << target << ")"<< endl;
    WaveShortMessage wsm;
    wsm.setName("data");
    t_channel channel = dataOnSch ? type_SCH : type_CCH;
    wsm.addBitLength(headerLength);
    wsm.addBitLength(dataLengthBits);
    switch (channel) {
        case type_SCH: wsm.setChannelNumber(Channels::SCH1); break; // Will be rewritten at Mac1609_4 to actual Service Channel. This is just so no controlInfo is needed
        case type_CCH: wsm.setChannelNumber(Channels::CCH); break;
    }
    wsm.setPsid(0);
    wsm.setPriority(dataPriority);
    wsm.setWsmVersion(1);
    wsm.setSerial(2);

    wsm.setTimestamp(simTime());
    wsm.setSenderAddress(MACToInteger());

    // wsm.setRecipientAddress(); // Set when will send

    wsm.setSource(source.c_str());
    wsm.setTarget(target.c_str());
    wsm.setSenderPos(curPosition);

    wsm.setSummaryVector(false);
    wsm.setRequestMessages(false);

    string data = "WSMData generated by " + source;
    wsm.setWsmData(data.c_str());

    if (epidemic::messageId < 10) {
        string msgIdTmp = "00" + to_string(epidemic::messageId);
        wsm.setGlobalMessageIdentificaton(msgIdTmp.c_str()); // Id 001 to 009
    } else if (epidemic::messageId < 100) {
        string msgIdTmp = "0" + to_string(epidemic::messageId);
        wsm.setGlobalMessageIdentificaton(msgIdTmp.c_str()); // Id 011 to 099
    } else {
        wsm.setGlobalMessageIdentificaton(to_string(epidemic::messageId).c_str()); // Id 100 and going on
    }
    wsm.setHopCount(beaconMessageHopLimit + 1);

    epidemic::messageId++;

    epidemicLocalMessageBuffer.insert(make_pair(wsm.getGlobalMessageIdentificaton(),wsm));
    epidemicLocalSummaryVector.insert(make_pair(wsm.getGlobalMessageIdentificaton(),true));
    //FIFO strategy to set the maximum size that a node is willing to allocate epidemic messages in its buffer
    queueFIFO.push(wsm.getGlobalMessageIdentificaton());
}

void epidemic::finish() {
    cout << "Number of Messages Generated: " << (epidemic::messageId - 1) << endl;
    recordScalar("#numMessageGenerated", (epidemic::messageId - 1));
}
